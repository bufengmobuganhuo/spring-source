@startuml
外部程序 -> AbstractBeanFactory: 使用getBean()方法获取Bean,\n在getBean()中调用了doGetBean()方法，\n如下是该方法的执行过程
AbstractBeanFactory -> ObjectFactory: getSingleton(beanName)方法先从缓存中获取Bean，\n处理那些已经被创建过的单例模式的bean，\n对这种bean的请求不需要重复创建。\n实际上是从一个ConcurrentHashMap中获取，\n如果不存在则使用抽象工厂模式的方法获取\n（根据不同的bean使用不同的工厂创建）
ObjectFactory -> AbstractBeanFactory: 如果创建的是一个普通bean则，直接返回，\n如果创建的是一个factoryBean，\n那么用这个factoryBean创建bean
AbstractBeanFactory -> AbstractBeanFactory: 如果上述取不到bean，\n则对IOC容器中的BeanDefinition是否存在进行检查，\n检查是否能在当前的BeanFactory中去的需要的Bean。\n如果取不到，则顺着双亲BeanFactory链一直向上查找
AbstractBeanFactory -> AbstractBeanFactory: 如果当前工厂已经是一个根工厂，\n则首先创建这个bean依赖的其他bean
AbstractBeanFactory -> AbstractAutowireCapableBeanFactory: 解决了所有依赖后，调用createBean()根据生命周期创建singleton或prototype等类型的bean
AbstractAutowireCapableBeanFactory -> AbstractAutowireCapableBeanFactory: 先判断要创建的bean是否可以实例化，\n这个类是否可以通过类装载器载入
AbstractAutowireCapableBeanFactory -> AbstractAutowireCapableBeanFactory: 如果Bean配置了PostProcessor, \n那么这里返回的是一个proxy
AbstractAutowireCapableBeanFactory -> AbstractAutowireCapableBeanFactory.doCreateBean: 调用doCreateBean()
AbstractAutowireCapableBeanFactory.doCreateBean -> AbstractAutowireCapableBeanFactory.doCreateBean: 在这个方法中，依次检查bean是否可以被实例化、\n如果是单例的则清除掉原有bean
AbstractAutowireCapableBeanFactory.doCreateBean -> AbstractAutowireCapableBeanFactory.createBeanInstance: 调用createBeanInstance()
AbstractAutowireCapableBeanFactory.createBeanInstance -> AbstractAutowireCapableBeanFactory.createBeanInstance: 如果可以使用工厂方法模式创建bean，则直接创建
AbstractAutowireCapableBeanFactory.createBeanInstance -> AbstractAutowireCapableBeanFactory.createBeanInstance: 如果有指定的构造函数，或构造函数有参数，\n则使用构造函数实例化
AbstractAutowireCapableBeanFactory.createBeanInstance -> SimpleInstantiationStrategy.instantiate: 使用默认的构造函数对Bean进行实例化，\n此处使用了策略模式，\n根据不同策略生成bean，\n默认策略是SimpleInstantiationStrategy
SimpleInstantiationStrategy.instantiate -> AbstractAutowireCapableBeanFactory.createBeanInstance: 优先使用构造函数或工厂方法模式创建，\n否则使用CGLIB创建
AbstractAutowireCapableBeanFactory.createBeanInstance -> AbstractAutowireCapableBeanFactory.doCreateBean
AbstractAutowireCapableBeanFactory.doCreateBean -> AbstractAutowireCapableBeanFactory:bean创建成功
AbstractAutowireCapableBeanFactory -> AbstractAutowireCapableBeanFactory.populateBean: 设置bean对象的依赖关系
AbstractAutowireCapableBeanFactory.populateBean -> AbstractAutowireCapableBeanFactory.populateBean: 首先对AutoWire的处理，可以根据名字或类型注入
AbstractAutowireCapableBeanFactory.populateBean -> AbstractAutowireCapableBeanFactory.applyPropertyValues: 对属性进行注入
AbstractAutowireCapableBeanFactory.applyPropertyValues -> BeanDefinitionValueResolver.resolveValueIfNecessary: 解析属性，根据属性类型的不同使用不同的方法解析
BeanDefinitionValueResolver.resolveValueIfNecessary -> BeanDefinitionValueResolver.resolveReference: 解析对象引用
BeanDefinitionValueResolver.resolveReference -> BeanDefinitionValueResolver.resolveReference: 获取Reference的名字
BeanDefinitionValueResolver.resolveReference -> BeanDefinitionValueResolver.resolveReference: 如果ref在双亲IOC容器中，则从双亲IOC容器中获取
BeanDefinitionValueResolver.resolveReference -> BeanDefinitionValueResolver.resolveReference: 如果从当前IOC容器获取，则会调用getBean()方法，触发依赖注入
BeanDefinitionValueResolver.resolveValueIfNecessary -> BeanDefinitionValueResolver.resolveValueIfNecessary: 对于array或list等会逐个解析其中的元素
BeanDefinitionValueResolver.resolveValueIfNecessary -> AbstractAutowireCapableBeanFactory.applyPropertyValues: 解析属性完成
AbstractAutowireCapableBeanFactory.applyPropertyValues -> AbstractNestablePropertyAccessor.setPropertyValue: 根据属性的不同类型进行注入
AbstractAutowireCapableBeanFactory.applyPropertyValues -> AbstractAutowireCapableBeanFactory.populateBean: 属性注入完成
AbstractAutowireCapableBeanFactory.populateBean  -> AbstractAutowireCapableBeanFactory: 设置bean对象的依赖关系完成
AbstractAutowireCapableBeanFactory -> AbstractAutowireCapableBeanFactory.initializeBean: 使用反射调用Bean的初始化方法,这些初始化方法需要在编写类时指定
AbstractBeanFactory -> 外部程序: 创建了bean之后，检查bean的类型，\n如果没有问题，则返回这个bean
@enduml